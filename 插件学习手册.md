# 插件学习手册

本手册面向希望为 VCPToolBox 编写或维护插件的开发者。内容涵盖插件的基本概念、清单（manifest）字段、通信协议、插件类型、生命周期、示例代码、调试要点与安全/测试建议。

## 一、核心概念一览
- PluginManager：宿主端的插件管理器，负责发现、加载、初始化、调用和关闭插件。
- manifest（plugin-manifest.json）：每个插件目录下的描述文件，声明插件名字、类型、entryPoint、communication 等元信息。
- protocol（manifest.communication.protocol）：指明插件与宿主之间通信的方式（例如 `direct`、`stdio`）。这个字段决定了插件如何被加载和调用。
- pluginType：插件的角色（`service`、`messagePreprocessor`、`synchronous`、`asynchronous`、`static`、`hybridservice` 等），决定宿主如何使用该插件。

## 二、支持的协议（communication.protocol）与行为
仓库实现中常见的协议有两类：`direct` 与 `stdio`（此外还有 `static` 插件类型和分布式工具的注册机制）。

1) direct
- 含义：宿主通过 `require()` 直接加载插件脚本（Node module）。
- 适用：`service`、`messagePreprocessor`、`hybridservice` 等需要与宿主深度集成、注册路由或在启动时执行初始化的插件。
- 生命周期：PluginManager 在发现插件时会 require(script)，并在 `loadPlugins()` 阶段对导出的模块调用 `initialize(initialConfig, dependencies)`（如果存在）。后续可直接调用模块导出的函数（如 `processToolCall`、`processMessages`、`registerApiRoutes`）。
- 优点：可直接注入依赖、注册 Express 路由、管理长期内存状态。
- 风险：运行在宿主进程，异常或恶意代码可能影响主进程。

2) stdio
- 含义：插件以外部进程运行（通过 manifest.entryPoint.command 启动），宿主通过 stdin/stdout 与之交互，数据用 JSON 编码。
- 适用：`synchronous`（一次性返回）和 `asynchronous`（先返回初始响应然后继续后台运行）类型的插件，或使用其他语言实现的插件。
- 行为：PluginManager 的 `executePlugin()` 会 spawn 子进程，把 input JSON 写入 stdin，读取 stdout，寻找首个完整 JSON（应包含 { status: 'success'| 'error', ... }）。
- 优点：进程隔离、可使用任意语言实现。
- 注意：必须遵守 stdin/stdout JSON 协议、处理超时、并正确返回 status 字段；异步插件可通过回调 URL 或宿主注入的环境变量进行后续交互。

3) static（插件类型）
- 含义：通常由宿主周期性运行命令（entryPoint.command），获取输出并用于更新占位符（systemPromptPlaceholders）。
- 行为：PluginManager 调用命令并把 stdout 作为占位符值，支持 cron 表达式调度。

4) 分布式工具（registerDistributedTools）
- 含义：远端服务器推送的工具会被注册为 `isDistributed=true` 并带有 serverId；这些工具由 WebSocketServer 转发调用，宿主本地不会 require 或 spawn 它们。

## 三、插件类型（pluginType）常见用法
- service：向外提供 HTTP API / 注册路由，通常 `direct`。
- messagePreprocessor：在消息进入主流程前进行修改/过滤，通常 `direct` 并导出 `processMessages(messages, config)`。
- synchronous：为 stdio 型的一次性工具，需要在 stdout 中返回最终 JSON 后退出。
- asynchronous：stdio 型的长运行工具，需先输出初始 JSON 表示接收成功可继续在后台运行，宿主会注入 CALLBACK_BASE_URL、PLUGIN_NAME_FOR_CALLBACK 等环境变量。
- static：周期性运行并更新占位符的简单命令型插件。
- hybridservice：既是 service 又可被作为工具调用的混合类型，通常 `direct`。

## 四、manifest（plugin-manifest.json）参考字段
- name: 插件唯一标识（字符串）。
- displayName: 可读名称。
- pluginType: 插件类型（见上）。
- entryPoint: { script: "AgentAssistant.js" } 或 { command: "python tool.py" }。
- communication: { protocol: "direct" | "stdio", timeout: 60000 }。
- configSchema: 一个键->类型的映射（'integer'|'boolean'|'string'），用于 PluginManager 从全局 env 或插件本地 config.env 中读取配置。
- capabilities: 可声明占位符、命令描述等（用于生成 VCP 描述）。
- refreshIntervalCron（仅 static）：cron 字符串，用于周期更新。

示例（direct 服务）:

```json
{
	"name": "AgentAssistant",
	"displayName": "Agent Assistant",
	"pluginType": "service",
	"entryPoint": { "script": "AgentAssistant.js" },
	"communication": { "protocol": "direct" },
	"configSchema": { "DebugMode": "boolean" }
}
```

示例（stdio 工具）:

```json
{
	"name": "WeatherReporter",
	"pluginType": "synchronous",
	"entryPoint": { "command": "python reporter.py" },
	"communication": { "protocol": "stdio", "timeout": 60000 }
}
```

## 五、初始化生命周期与宿主交互（PluginManager 行为）
1. 发现（discovery）：PluginManager 读取 `Plugin/` 下的所有 manifest。若存在插件本地 `config.env` 会解析并合并到 manifest.pluginSpecificEnvConfig。
2. 加载（load）：对于 `direct` 的 service / preprocessor 模块，PluginManager 会 `require(script)` 并把模块加入 `modulesToInitialize`。对于 stdio / static，通常不会 require。
3. 初始化（initialize）：按预处理器顺序优先，PluginManager 会为每个模块准备 `initialConfig`（基于 manifest.configSchema 与环境变量）和 `dependencies`（例如 vcpLogFunctions、vectorDBManager 等），如果模块导出 `initialize`，宿主会 `await module.initialize(initialConfig, dependencies)`。
4. 服务注册（initializeServices）：当 Express app 可用时，PluginManager 会调用 service 模块的 `registerApiRoutes(router, pluginConfig, projectBasePath, webSocketServer)` 或向旧式 `registerRoutes(app, pluginConfig, projectBasePath)` 兼容。
5. 调用（run）：
	- direct 模块：直接调用导出函数（例如 `processToolCall`、`processMessages`）。
	- stdio 模块：调用 `executePlugin()`，spawn 子进程并用 stdin/stdout 交换。
	- static 插件：周期性运行命令以更新占位符。
6. 关闭（shutdown）：PluginManager 在退出或重载时会调用已加载模块的 `shutdown()`（如果导出）并取消所有定时任务。

## 六、`initialize` 的契约（plugin 作者应遵守）
- 签名：async function initialize(initialConfig, dependencies)
- 输入：
	- initialConfig：PluginManager 基于 manifest.configSchema 与 env 构建的配置对象（包含 DebugMode、PORT、Key、PROJECT_BASE_PATH 等）
	- dependencies：宿主注入的能力，例如 `{ vcpLogFunctions: { pushVcpLog, pushVcpInfo }, vectorDBManager, getSingleEmbedding }`
- 行为预期：
	- 快速返回（不要阻塞很长时间）并把耗时任务交给后台线程 / 定时器
	- 在需要时注册 Express 路由或把服务函数暴露给宿主
	- 在 module.exports 上保存必要句柄以便 shutdown() 清理
	- 出错时抛异常或 reject Promise；宿主会捕获并记录错误

## 七、实现示例

1) direct（Node 模块）最小模板

```javascript
// myService.js
let _timer;
async function initialize(config, dependencies) {
	// 保存配置与依赖
	this.config = config || {};
	this.deps = dependencies || {};

	if (this.config.startIntervalMs) {
		_timer = setInterval(() => { /* 周期任务 */ }, this.config.startIntervalMs);
	}
	return { status: 'initialized' };
}

function registerApiRoutes(router, config, projectBasePath, wss) {
	router.get('/ping', (req, res) => res.json({ ok: true }));
}

async function shutdown() {
	if (_timer) clearInterval(_timer);
}

module.exports = { initialize, registerApiRoutes, shutdown };
```

2) stdio（Python）最小模板

```python
#!/usr/bin/env python3
import sys, json

def main():
		try:
				raw = sys.stdin.read()
				data = json.loads(raw or '{}')
				# 处理 data
				out = {"status": "success", "result": {"message": "ok"}}
				print(json.dumps(out))
		except Exception as e:
				print(json.dumps({"status": "error", "error": str(e)}))

if __name__ == '__main__':
		main()
```

3) stdio（NodeJS）最小模板

```javascript
// tool.js
process.stdin.setEncoding('utf8');
let input = '';
process.stdin.on('data', c => input += c);
process.stdin.on('end', () => {
	try {
		const args = JSON.parse(input || '{}');
		const out = { status: 'success', result: { echo: args } };
		console.log(JSON.stringify(out));
	} catch (e) {
		console.log(JSON.stringify({ status: 'error', error: e.message }));
	}
});
```

## 八、调试与常见问题
- PluginManager debug 模式：通过环境变量 DebugMode=true 启用，会打印 `initialConfig`（敏感字段掩码）、加载顺序与初始化错误。
- direct 插件没被初始化的常见原因：manifest.communication.protocol 不是 "direct"，或 manifest.entryPoint.script 缺失，或 PluginManager 发现时被判断为非 service/preprocessor 类型。
- stdio 插件常见错误：未按 JSON 协议输出、超时（检查 manifest.communication.timeout 与宿主默认）、未正确读取 stdin。
- static 插件：若占位符未更新，先在本地命令行单独运行 entryPoint.command 检查 stdout。

## 九、安全与权限建议
- 对 `direct` 插件只加载可信代码，避免在不受信任的环境中 require 任意插件脚本。
- 对 `stdio` 插件注入的环境变量（如 DECRYPTED_AUTH_CODE）要慎重，仅对受信任的插件开启。
- 插件限制：尽可能减少插件对宿主全局状态的修改，使用明确导出接口与依赖注入。

## 十、测试与发布流程建议
- 本地测试：
	1. 对 direct 插件，写一个小脚本 require 并调用 initialize()，验证返回和 registerApiRoutes 行为。
	2. 对 stdio 插件，在命令行手动运行 entryPoint.command，给 stdin 输入模拟 JSON，验证 stdout。
- 单元/集成：为关键逻辑添加简单的单元测试（例如 agent 配置解析、message preprocessor 的处理函数）并在 CI 中运行。

## 十一、快速上手清单（Checklist）
- [ ] 为插件添加 `plugin-manifest.json` 并正确设置 `communication.protocol` 与 `pluginType`。
- [ ] 若选择 `direct`，实现并导出 `initialize(initialConfig, dependencies)`（如需要）和 `shutdown()`（如保留资源）。
- [ ] 若选择 `stdio`，确保脚本接受 stdin、输出首个合法 JSON 且按 manifest.timeout 工作。
- [ ] 若需要 HTTP 路由，实现 `registerApiRoutes(router, pluginConfig, projectBasePath, webSocketServer)`。
- [ ] 在本地独立运行并验证命令或模块行为，再加入 `Plugin/` 目录。

## 十二、FAQ（精简）
- Q: 为什么我的 direct 插件没有被 `initialize` 调用？
	A: 检查 manifest 中 `communication.protocol` 是否是 `direct`，并且 `pluginType` 是否是 `service` 或 `messagePreprocessor`（PluginManager 只对这些类型进行 require/初始化）。
- Q: stdio 插件如何做异步回调？
	A: 使用 manifest.communication.timeout 并从环境变量读取 `CALLBACK_BASE_URL` 或宿主注入的 `PLUGIN_NAME_FOR_CALLBACK`，向宿主或外部回调接口报告结果。

---

如果你愿意，我可以：
- 扫描仓库并生成按协议分组的插件清单（manifest -> protocol），或
- 为某个具体插件（你指定）生成 `initialize` / `registerApiRoutes` / `shutdown` 模板并做一次简单的本地验证脚本。

完成。

